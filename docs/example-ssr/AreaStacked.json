{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, ScaledSvg, Html, flatten } from 'layercake';\n  import { stack } from 'd3-shape';\n  import { scaleOrdinal } from 'd3-scale';\n  import { format, precisionFixed } from 'd3-format';\n  import { timeParse, timeFormat } from 'd3-time-format';\n\n  import AxisX from './components/AxisX.html.svelte';\n  import AxisY from './components/AxisY.html.svelte';\n  import AreaStacked from './components/AreaStacked.svelte';\n\n  // This example loads csv data as json using rollup-plugin-dsv\n  import data from './data/fruit.csv';\n\n  const xKey = 'month';\n  const yKey = [0, 1];\n  const zKey = 'key';\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ff00cc', '#ff7ac7', '#ffb3c0', '#ffe4b8'];\n\n  data.forEach(d => {\n    d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey];\n    seriesNames.forEach(name => {\n      d[name] = +d[name];\n    });\n  });\n\n  /* --------------------------------------------\n   * Create a stacked data structure\n   */\n  const stackData = stack()\n    .keys(seriesNames);\n\n  const series = stackData(data);\n\n  const formatTickX = timeFormat('%b. %-d')\n  const formatTickY = d => format(`.${precisionFixed(d)}s`)(d);\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr={true}\n    percentRange={true}\n    padding={{ top: 0, right: 0, bottom: 20, left: 17 }}\n    x={d => d.data[xKey]}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zDomain={seriesNames}\n    zRange={seriesColors}\n    flatData={flatten(series)}\n    data={series}\n  >\n    <Html>\n      <AxisX\n        formatTick={formatTickX}\n      />\n      <AxisY\n        baseline={true}\n        formatTick={formatTickY}\n      />\n    </Html>\n    <ScaledSvg>\n      <AreaStacked/>\n    </ScaledSvg>\n  </LayerCake>\n</div>"},"dek":"Stack area charts using D3's [stack](https://github.com/d3/d3-shape#stacks) function. Because this will create a nested data structure, we use LayerCake's `flatten` function and the `flatData` option from which we measure the extents.\n","components":[{"title":"./components/AxisX.html.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yScale, padding } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let ticks = undefined;\n  export let yTick = 7;\n  export let dyTick = 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n</script>\n\n<div class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i}\n    {#if gridlines !== false}\n      <div class=\"gridline\" style='left:{$xScale(tick)}%;top: -{$padding.top}px;bottom: 0;'></div>\n    {/if}\n    <div\n      class='tick tick-{ i }'\n      style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;top:100%;'>\n      <div\n        class=\"text\"\n        style='top:{(yTick + dyTick)}px;'>{formatTick(tick)}</div>\n    </div>\n  {/each}\n  {#if baseline === true}\n    <div class=\"baseline\" style='top: 100%;width: 100%;'></div>\n  {/if}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  .axis.snapTicks .tick:last-child {\n    transform: translateX(-50%);\n  }\n  .axis.snapTicks .tick:first-child {\n    transform: translateX(50%);\n  }\n</style>"},{"title":"./components/AxisY.html.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, xScale, yScale } = getContext('LayerCake');\n\n  export let ticks = 4;\n  export let gridlines = true;\n  export let baseline = false;\n  export let formatTick = d => d;\n  export let xTick = -4;\n  export let yTick = 2;\n  // export let dxTick = 0;\n  // export let dyTick = -4;\n  // export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<div class='axis y-axis' style='transform:translate(-{$padding.left}px, 0)'>\n  {#each tickVals as tick, i}\n    <div class='tick tick-{i}' style='top:{$yScale(tick) + (isBandwidth ? $yScale.bandwidth () / 2 : 0)}%;left:{$xRange[0]}%;'>\n      {#if gridlines !== false}\n        <div class=\"gridline\" style='top:0;left:{isBandwidth ? $padding.left : 0}px;right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if baseline !== false && i === 0}\n        <div class=\"gridline baseline\" style='top:0;left:{isBandwidth ? $padding.left : 0};right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      <div\n        class=\"text\"\n        style='\n          top:{yTick - 3}px;\n          left:{isBandwidth ? ($padding.left + xTick) : 0}px;\n          transform: translate({isBandwidth ? '-100%' : 0}, {isBandwidth ? -50 - Math.floor($yScale.bandwidth() / -2) : '-100'}%);\n        '\n      >{formatTick(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 12px;\n    width: 100%;\n    font-weight: 100;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./components/AreaStacked.svelte","contents":"<script>\n  import { area } from 'd3-shape';\n  import { scaleOrdinal } from 'd3-scale';\n\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yScale, zGet } = getContext('LayerCake');\n\n  $: areaGen = area()\n    .x(d => $xGet(d))\n    .y0(d => $yScale(d[0]))\n    .y1(d => $yScale(d[1]));\n</script>\n\n<g class=\"area-group\">\n  {#each $data as d}\n    <path\n      class='path-area'\n      d='{areaGen(d)}'\n      fill='{$zGet(d)}'\n    ></path>\n  {/each}\n</g>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}]}