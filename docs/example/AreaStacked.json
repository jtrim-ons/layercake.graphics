{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Svg, flatten } from 'layercake';\n  import { stack } from 'd3-shape';\n  import { scaleOrdinal } from 'd3-scale';\n  import { format, precisionFixed } from 'd3-format';\n  import { timeParse, timeFormat } from 'd3-time-format';\n\n  import AxisX from './components/AxisX.svelte';\n  import AxisY from './components/AxisY.svelte';\n  import AreaStacked from './components/AreaStacked.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './data/fruit.csv';\n\n  const xKey = 'month';\n  const yKey = [0, 1];\n  const zKey = 'key';\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ff00cc', '#ff7ac7', '#ffb3c0', '#ffe4b8'];\n\n  data.forEach(d => {\n    d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey];\n    seriesNames.forEach(name => {\n      d[name] = +d[name];\n    });\n  });\n\n  /* --------------------------------------------\n   * Create a stacked data structure\n   */\n  const stackData = stack()\n    .keys(seriesNames);\n\n  const series = stackData(data);\n\n  const formatTickX = timeFormat('%b. %-d')\n  const formatTickY = d => format(`.${precisionFixed(d)}s`)(d);\n</script>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 0, right: 0, bottom: 20, left: 17 }}\n    x={d => d.data[xKey]}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zDomain={seriesNames}\n    zRange={seriesColors}\n    flatData={flatten(series)}\n    data={series}\n  >\n    <Svg>\n      <AxisX\n        formatTick={formatTickX}\n      />\n      <AxisY\n        formatTick={formatTickY}\n      />\n      <AreaStacked/>\n    </Svg>\n  </LayerCake>\n</div>"},"dek":"Stack area charts using D3's [stack](https://github.com/d3/d3-shape#stacks) function. Because this will create a nested data structure, we use LayerCake's `flatten` function and the `flatData` option from which we measure the extents.\n","components":[{"title":"./components/AxisX.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yScale, yRange } = getContext('LayerCake');\n\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let baseline = false;\n  export let snapTicks = false;\n  export let ticks = undefined;\n  export let xTick = undefined;\n  export let yTick = 16;\n  export let dxTick = 0;\n  export let dyTick = 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class='axis x-axis'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yRange[0]})'>\n      {#if gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text\n        x=\"{xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0 }\"\n        y='{yTick}'\n        dx='{dxTick}'\n        dy='{dyTick}'\n        text-anchor='{textAnchor(i)}'>{formatTick(tick)}</text>\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/AxisY.svelte","contents":"<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, xScale, yScale } = getContext('LayerCake');\n\n  export let ticks = 4;\n  export let gridlines = true;\n  export let formatTick = d => d;\n  export let xTick = 0;\n  export let yTick = 0;\n  export let dxTick = 0;\n  export let dyTick = -4;\n  export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n  {#each tickVals as tick, i}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          x2='100%'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      <text\n        x='{xTick}'\n        y='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n        dx='{isBandwidth ? -5 : dxTick}'\n        dy='{isBandwidth ? 4 : dyTick}'\n        style=\"text-anchor:{isBandwidth ? 'end' : textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./components/AreaStacked.svelte","contents":"<script>\n  import { area } from 'd3-shape';\n  import { scaleOrdinal } from 'd3-scale';\n\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yScale, zGet } = getContext('LayerCake');\n\n  $: areaGen = area()\n    .x(d => $xGet(d))\n    .y0(d => $yScale(d[0]))\n    .y1(d => $yScale(d[1]));\n</script>\n\n<g class=\"area-group\">\n  {#each $data as d}\n    <path\n      class='path-area'\n      d='{areaGen(d)}'\n      fill='{$zGet(d)}'\n    ></path>\n  {/each}\n</g>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}]}